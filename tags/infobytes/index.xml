<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>infobytes on CPP GameDev</title><link>/tags/infobytes/</link><description>Recent content in infobytes on CPP GameDev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 25 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/infobytes/index.xml" rel="self" type="application/rss+xml"/><item><title>Memory Management</title><link>/posts/memory-management-infobyte/</link><pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate><guid>/posts/memory-management-infobyte/</guid><description>C++ Memory Model Unlike higher level languages, the programmer is responsible for all memory management in C/C++. Automatic/stack-allocated memory is automatically cleaned up when it goes out of scope (hence automatic storage duration) and should always be preferred, even for managing heap memory (smart pointers). This is the basis of RAII.
A definition like char x = 'a'; will result in the compiler storing enough space (1 byte) to hold one char.</description></item><item><title>Primitive Data Types</title><link>/posts/primitive-types-infobyte/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>/posts/primitive-types-infobyte/</guid><description>Primitive Data Types C/C++ being rather old languages, the width of types like int, long, etc have changed over time, from 16 bit CPUs to 32 bit and now 64 bit ones. This enables programs using such types to be generic and largely usable on all these target CPU architectures (potentially even ones in the future). The only generic type that has a guaranteed size is char (1 signed/unsigned byte on all modern platforms) - this is also a reason why files are read as arrays of chars (bytes).</description></item></channel></rss>