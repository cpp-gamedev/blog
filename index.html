<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.65.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>CPP GameDev&nbsp;&ndash;&nbsp;Discussion around C++ game programming</title><link rel=stylesheet href=/css/core.min.350463598a0d573d76ab4b07af8573e375f4ecedd88570d214cd6fcfeff9d18d24161335c46a7c6c438b307e881e21ce.css integrity=sha384-NQRjWYoNVz12q0sHr4Vz43X07O3YhXDSFM1vz+/50Y0kFhM1xGp8bEOLMH6IHiHO><link rel=alternate type=application/rss+xml href=/index.xml title="CPP GameDev"><body><div class=base-body><section id=header class="site header"><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/cppgamedev.jpg alt><span class="site name">CPP GameDev</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>Categories</a><a class="nav item" href=/tags/>Tags</a><a class="nav item" href=https://github.com/cpp-gamedev target=_blank>github</a><a class="nav item" href=https://discord.gg/2NvA5jn target=_blank>discord</a></nav></div></span></div><div class="site slogan"><span class=title>Discussion around C++ game programming</span></div></section><div id=content><ul class="note list"><li class=item><a class=note href=/collab/topics-outline/><p class="note title">Topics Outline</p><p class="note date">Wednesday, February 26, 2020</p><p class="note content">Pre-3D Topics Environment Setup
CMake basics Dealing with paths - preprocessor vs working directory vs runtime directory, relative vs absolute Limiting symbols in global scope (everything is global by default) Debugging basics: embedding symbols, using breakpoints, watching variables, changing memory, etc Enabling useful compiler warnings I/O, OS, code scope
Generic types vs fixed-size types Manual memory management IO and type conversions: &lt;iostream>, std::getline, std::string/std::string_view, std::atoi, etc Containers: std::stringstream, std::vector, std::unordered_map, std::unordered_set, std::list, std::deque, std::bitset Files: &lt;fstream>, std::filesystem Random generation: &lt;random> Template functions Advanced C++<span class=mldr>&mldr;more</span></p></a><p class="note labels"><a class=category href=/categories/collab/>collab</a><a class=tag href=/tags/projects/>projects</a></p></li><li class=item><a class=note href=/posts/memory-management-infobyte/><p class="note title">Memory Management</p><p class="note date">Tuesday, February 25, 2020</p><p class="note content">C++ Memory Model Unlike higher level languages, the programmer is responsible for all memory management in C/C++. Automatic/stack-allocated memory is automatically cleaned up when it goes out of scope (hence automatic storage duration) and should always be preferred, even for managing heap memory (smart pointers). This is the basis of RAII.
A definition like char x = 'a'; will result in the compiler storing enough space (1 byte) to hold one char.<span class=mldr>&mldr;more</span></p></a><p class="note labels"><a class=category href=/categories/posts/>posts</a><a class=tag href=/tags/infobytes/>infobytes</a><a class=tag href=/tags/c++/>c++</a></p></li><li class=item><a class=note href=/posts/primitive-types-infobyte/><p class="note title">Primitive Data Types</p><p class="note date">Monday, February 24, 2020</p><p class="note content">Primitive Data Types C/C++ being rather old languages, the width of types like int, long, etc have changed over time, from 16 bit CPUs to 32 bit and now 64 bit ones. This enables programs using such types to be generic and largely usable on all these target CPU architectures (potentially even ones in the future). The only generic type that has a guaranteed size is char (1 signed/unsigned byte on all modern platforms) - this is also a reason why files are read as arrays of chars (bytes).<span class=mldr>&mldr;more</span></p></a><p class="note labels"><a class=category href=/categories/posts/>posts</a><a class=tag href=/tags/infobytes/>infobytes</a><a class=tag href=/tags/c++/>c++</a></p></li><li class=item><a class=note href=/posts/2020-february-challenge/><p class="note title">February Challenges</p><p class="note date">Saturday, February 1, 2020</p><p class="note content">Number of words in a string Mini exercise: count the number of words in a string. bonus points: count the number of characters in each word Note: you can do both in one pass
Short Exercise: Create a function to &ldquo;bisect&rdquo; a string given a delimiter: "id=fubar", '=' should return id and fubar. Prototype: std::pair&lt;std::string, std::string> bisect(std::string_view str, char delim); pair can be found in &lt;utility>. string_view instead of string const& allows for use of string literals / C strings without suffering a pointless string allocation.<span class=mldr>&mldr;more</span></p></a><p class="note labels"><a class=category href=/categories/posts/>posts</a><a class=tag href=/tags/challenges/>challenges</a></p></li></ul></div><section id=footer class=footer><div class=footer-wrap><p class=copyright>CPP GameDev</p><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank>Hugo</a><span> and the </span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank>Notepadium</a></p></div></section></div></body></html>