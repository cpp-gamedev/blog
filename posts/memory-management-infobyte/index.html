<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.65.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>Memory Management&nbsp;&ndash;&nbsp;CPP GameDev</title><link rel=stylesheet href=/css/core.min.350463598a0d573d76ab4b07af8573e375f4ecedd88570d214cd6fcfeff9d18d24161335c46a7c6c438b307e881e21ce.css integrity=sha384-NQRjWYoNVz12q0sHr4Vz43X07O3YhXDSFM1vz+/50Y0kFhM1xGp8bEOLMH6IHiHO><body><div class=base-body><section id=header class="site header"><div class="header wrap"><span class="header left-side"><a class="site home" href=/><img class="site logo" src=/cppgamedev.jpg alt><span class="site name">CPP GameDev</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>Categories</a><a class="nav item" href=/tags/>Tags</a><a class="nav item" href=https://github.com/cpp-gamedev target=_blank>github</a><a class="nav item" href=https://discord.gg/2NvA5jn target=_blank>discord</a></nav></div></span></div><div class="site slogan"><span class=title>Discussion around C++ game programming</span></div></section><div id=content><div class=article-container><section class="article header"><h1 class="article title">Memory Management</h1><p class="article date">Tuesday, February 25, 2020</p></section><article class="article markdown-body"><h3 id=c-memory-model>C++ Memory Model</h3><p>Unlike higher level languages, the programmer is responsible for <em>all</em> memory management in C/C++. Automatic/stack-allocated memory is automatically cleaned up when it goes out of scope (hence <code>automatic storage duration</code>) and should always be preferred, even for managing heap memory (smart pointers). This is the basis of RAII.</p><p>A definition like <code>char x = 'a';</code> will result in the compiler storing enough space (1 byte) to hold one <code>char</code>. Thus the size of the entire type must be known at compile/link time, and the compiler will use this type information to restrict operations on variables/data. This metadata is also used at runtime for RTTI (if enabled), eg <code>dynamic_cast</code>. This makes C++ a statically typed language.</p><p>C++ has a very strong notion of <strong>scope</strong>, the most common tool to work with them being braces (<code>{}</code>): all variables defined within such a scope will be destroyed after the scope ends. Apart from their appearance in functions, <code>struct</code>s, <code>class</code>es, and <code>namespace</code>s, you can introduce an unnamed <code>{}</code> scope block almost anywhere you like.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>{
    Foo foo;    <span style=color:#75715e>// allocated on the stack, no heap/malloc involved
</span><span style=color:#75715e></span>}   <span style=color:#75715e>// foo destroyed here
</span></code></pre></div><p>When the lifetime of an object is indeterminate at compile time, scope cannot be used to clean it up, and it needs to be allocated on the heap. Traditionally this was done via the <code>new</code> operator, which takes in a type (and arguments), allocates sufficient memory for it on the heap (via <code>malloc</code>), calls the (appropriate) constructor, and returns a pointer to this object. Such a pointer needs to have operator <code>delete</code> invoked on it once its done, which calls the destructor and then releases the associated memory (via <code>free</code>). This is not required/recommended anymore; instead we model <em>object ownership</em> and use smart pointers as member variables of owning objects instead.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>{
    Foo<span style=color:#f92672>*</span> foo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Foo;    <span style=color:#75715e>// allocated on the heap, must be manually deleted
</span><span style=color:#75715e></span>}   <span style=color:#75715e>// memory leak, pointer to heap allocated memory is lost
</span></code></pre></div><p>Storing the pointer in a &ldquo;higher&rdquo; scope seems to solve the problem, but introduces another one:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>Foo<span style=color:#f92672>*</span> foo <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
{
    foo <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Foo;
    <span style=color:#75715e>// operations
</span><span style=color:#75715e></span>}
<span style=color:#66d9ef>delete</span> foo; <span style=color:#75715e>// if an operation throws/returns before this line, there&#39;s now a leak
</span></code></pre></div><p>C++11 introduced smart pointers, which live on the stack and manage heap memory of any type you provide. Their destructors take care of deleting the allocated pointers. By default, always use <code>std::unique_ptr</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>{
    <span style=color:#66d9ef>auto</span> foo <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_unique<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>();
}   <span style=color:#75715e>// foo (unique_ptr&lt;Foo&gt;) is a stack object, so it gets destroyed here / on return / on throw / etc (as soon as
</span><span style=color:#75715e></span>    <span style=color:#75715e>// this scope ends); unique_ptr&lt;Foo&gt;&#39;s destructor then calls delete on the underlying pointer
</span></code></pre></div><p>Modern C++ thus warrants designing dynamic memory allocation around ownership models.</p><p>A few important consequences of all this:</p><ul><li>A called function&rsquo;s parameters are evaluated and memory for its arguments allocated (on the function stack frame) before it is invoked</li><li>A function&rsquo;s return value can often be <em>elided</em>, ie, a copy avoided by emplacing the result directly in lhs memory; this is even more efficient than move semantics, and is called <strong>Return Value Optimisation</strong></li><li>Arrays live on <em>the stack!</em> Be careful not to overflow due to huge arrays (or endless recursion)</li><li>Using modern C++ you should not need to deal with owning pointers (via <code>new</code>) <em>at all</em></li><li>A common misconception is that now &ldquo;raw pointers are bad&rdquo;; this is untrue: raw <em>owning</em> pointers are bad, raw <em>observational</em> pointers are still exceptionally &ldquo;good&rdquo;</li></ul></article><section class="article labels"><a class=category href=/categories/posts/>posts</a><a class=tag href=/tags/infobytes/>infobytes</a><a class=tag href=/tags/c++/>c++</a></section></div><section class="article navigation"><p><a class=link href=/posts/primitive-types-infobyte/><span class=li>&rarr;</span>Primitive Data Types</a></p></section></div><section id=footer class=footer><div class=footer-wrap><p class=copyright>CPP GameDev</p><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank>Hugo</a><span> and the </span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank>Notepadium</a></p></div></section></div></body></html>