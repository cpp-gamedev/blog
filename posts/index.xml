<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on CPP GameDev</title><link>/posts/</link><description>Recent content in Posts on CPP GameDev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 24 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Debugging</title><link>/posts/debugging-infobyte/</link><pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate><guid>/posts/debugging-infobyte/</guid><description>Debugging Symbols When invoking a C++ compiler, several options/flags can be passed, including optimisation level, pre-processor defines, and whether to include debugging symbols in the binary. These symbols are effectively mappings between binary addresses and source code (file, line number, symbol name, etc), which a compatible debugger can use. Including debugging symbols dramatically increases the size of the resulting binary, often by orders of magnitude.
A debugger (given an executable with debugging symbols) offers many useful features, such as stepping through code one line at a time, setting breakpoints, watching variables, changing values stored in memory, the entire call stack (when broken), etc.</description></item><item><title>Memory Management</title><link>/posts/memory-management-infobyte/</link><pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate><guid>/posts/memory-management-infobyte/</guid><description>C++ Memory Model Unlike higher level languages, the programmer is responsible for all memory management in C/C++. Automatic/stack-allocated memory is automatically cleaned up when it goes out of scope (hence automatic storage duration) and should always be preferred, even for managing heap memory (smart pointers). This is the basis of RAII.
A definition like char x = 'a'; will result in the compiler storing enough space (1 byte) to hold one char.</description></item><item><title>Primitive Data Types</title><link>/posts/primitive-types-infobyte/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>/posts/primitive-types-infobyte/</guid><description>Primitive Data Types C/C++ being rather old languages, the width of types like int, long, etc have changed over time, from 16 bit CPUs to 32 bit and now 64 bit ones. This enables programs using such types to be generic and largely usable on all these target CPU architectures (potentially even ones in the future). The only generic type that has a guaranteed size is char (1 signed/unsigned byte on all modern platforms) - this is also a reason why files are read as arrays of chars (bytes).</description></item><item><title>February Challenges</title><link>/posts/2020-february-challenge/</link><pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate><guid>/posts/2020-february-challenge/</guid><description>Number of words in a string Mini exercise: count the number of words in a string. bonus points: count the number of characters in each word Note: you can do both in one pass
Short Exercise: Create a function to &amp;ldquo;bisect&amp;rdquo; a string given a delimiter: &amp;quot;id=fubar&amp;quot;, '=' should return id and fubar. Prototype: std::pair&amp;lt;std::string, std::string&amp;gt; bisect(std::string_view str, char delim); pair can be found in &amp;lt;utility&amp;gt;. string_view instead of string const&amp;amp; allows for use of string literals / C strings without suffering a pointless string allocation.</description></item></channel></rss>